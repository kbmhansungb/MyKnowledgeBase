---
tags:
  - TestDrivenDevelopment
---
> 테스트 케이스를 만들다 보면, 보이지 않았던 것들이 보입니다.

TDD란 Test Driven Development의 약자로 '테스트 주도 개발'이라고 합니다. 반복 테스트를 이용한 소프트웨어 방법론으로, 작은 단위의 테스트 케이스를 작성하고 이를 통과하는 코드를 추가하는 단계를 반복하여 구현합니다.

짧은 개발 주기의 반복에 의존하는 개발 프로세스이며 애자일 방법론 중 하나인 eXtream Programming (XP)의 'Test-First' 개념에 기반을 둔 단순한 설계를 중요시합니다.

**TDD를 이용하여 다음을 기대할 수 있습니다.**
- 코드가 프로그래머의 손을 벗어나기 전에 빠르게 피드백을 받을 수 있습니다.
- 작성한 코드의 불안정성을 개선하여 생산성을 높일 수 있습니다.
- 프로그래머의 오버 코딩을 방지합니다.
- 테스트 코드를 작성하는 과정에서 히스토리가 남아, 과거 의사결정을 쉽게 상기할 수 있습니다.

> eXtream Programming(XP)는 미래에 대한 예측을 최대한 하지 않고, 지속적으로 프로토타입을 완성하는 애자일 방법론 중 하나입니다. 이 방법론은 추가 요구사항이 생기더라도, 실시간으로 반영할 수 있습니다.

> 단위 테스트(Unit test)는 말 그대로 한 단위만을 테스트하는 것입니다.

## 단위 테스트(Unit test)
단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트입니다.

단위 테스트에서 테스트 대상 단위의 크기는 엄격하게 정해져 있지 않습니다. **하지만, 일반적으로 클래스 또는 메서도 수준으로 정해집니다. 단위의 크기가 작을 수록 단위의 복잡성이 낮아집니다.** 따라서, 단위 테스트를 활용하여 동작을 표현하기 더 쉬워집니다. 즉, 테스트 대상 단위의 크기를 작게 설정해서 단위 테스트를 최대한 간단하고 디버깅 하기 쉽게 작성해야 합니다.

**단위 테스트는 실제 코드를 작성하기 전에 작성해야 하며, 이 규칙은 TDD를 수행하는 경우 반드시 따라야 하는 규칙입니다.**

[Testing and Test Driven Development in Unreal · ben🌱ui (benui.ca)](https://benui.ca/unreal/unreal-testing-introduction/)의 예를 요약하면 다음과 같습니다.
1. 지원 기능을 보고, 클래스와 메서드를 생성
2. 지원 사항을 충족할 테스트 케이스를 작성
3. 메서드를 구현하며, 테스트 케이스를 만족

### 유닛 테스트 작성을 위한 원칙 FIRST
* **FAST**
	* **테스트는 빨라야 한다. 여기서 빠름의 기준은 밀리 초(ms)입니다.** 단위 테스트를 테스트하는 데 있어 실행 시간이 0.5 초 또는 0.25 초가 걸리는 테스트는 빠른 테스트가 아닙니다.
	* 하나의 프로젝트에서 적게는 몇백 개에서 많게는 수천 개의 테스트를 할 수 있으므로 테스트의 실행 시간은 빨라야 합니다. 만약 테스트가 느리다면 개발자는 테스트를 주저하게 되고 자주 검증하지 않은 소스코드는 그만큼 버그가 발생할 확률이 높아집니다.
* **Independent** 
	* **테스트에 사용된 데이터들은 서로 의존하면 안 됩니다.** 테스트에 필요한 데이터는 테스트 내부에서 독립적으로 사용해야 합니다.  
	* 만약 데이터가 서로에게 의존하면 테스트 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지기 때문입니다.
	* 때론 데이터의 존재 여부를 찾는 테스트가 있는 경우엔 해당 데이터는 테스트 내부에서 생성되어야 하며 나중에 테스트에 영향을 미치지 않도록 제거해야 한다.
* **Repeatable**
	* **테스트는 어느 환경에서든 반복적으로 테스트를 실행할 수 있어야 합니다.** 여기서 환경은 네트워크 나 데이터베이스에 의존하지 않는 환경을 뜻합니다. 결론적으로 인터넷이 되든 안 되든 데이터베이스에 접속하든 안 하든 언제 어디서나 테스트를 할 수 있어야 합니다.
	* 환경에 의존하지 않는 테스트가 실패할 수 있는 유일한 이유는 오로지 테스트할 클래스 또는 메소드가 제대로 작동하지 않기 때문입니다.
* **Selef-Validating**
	* **테스트는 자체 검증이 되어야 합니다.** 테스트의 검증은 수작업이 아닌 자동화가 되어야 하는데 테스트가 실행될 때마다 메서드 출력이 올바른지를 확인하는 것은 개발자가 결정해서는 안 됩니다.
* **Timely**
	* **좋은 단위 테스트는 미루지 않고 즉시 작성**합니다. 단위 테스트는 소프트웨어 개발의 완성도, 품질을 높이는 좋은 습관입니다.
	* 만약 테스트를 제때 작성하지 않고 미루어 작성하지 않는다면 코드에 결함이 발생할 확률이 높아집니다.

## 통합 테스트(Integration test)
**통합 테스트는 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트입니다.**

통합 테스트는 단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부 라이브러리)까지 묶어 검증할 때 사용합니다. 이는 DB에 접근하거나 전체 코드와 다양한 환경이 제대로 작동하는지 확인하는데 필요한 모든 작업을 수행할 수 있습니다. 그러나, 통합 테스트가 응용 프로그램이 완전하게 작동하는 걸 무조건 증명하지는 않습니다.

통합 테스트의 장점은 단위 테스트에서 발견하기 어려운 버그를 찾을 수 있다는 점입니다. 예를 들어, 통합 테스트에서는 환경 버그(ex. 싱글 코어 CPU에서는 잘 실행되나 쿼드 코어 CPU에서는 잘 실행되지 않음)이 발생할 수 있습니다.

한편, 통합 테스트의 단점은 단위 테스트보다 더 많은 코드를 테스트하기 때문에 신뢰성이 떨어질 수 있다는 점이다. 또, 어디서 에러가 발생했는지 확인하기 쉽지 않아 유지 보수하기 힘들다는 점도 있다.

## 테스트 케이스 만들기
**객체 지향 프로그래밍 에서 모의 ​​객체([Mock object](https://en.wikipedia.org/wiki/Mock_object))는 제어된 방식으로 실제 객체의 동작을 모방하는 시뮬레이션 객체**이며, 대부분 소프트웨어 테스트 이니셔티브의 일부입니다. 프로그래머는 일반적으로 자동차 디자이너가 충돌 테스트 더미 를 사용 하여 차량 충돌 시 인간의 동적 동작 을 시뮬레이션 하는 것과 거의 동일한 방식으로 다른 개체의 동작을 테스트하기 위해 모의 개체를 만듭니다. 이 기술은 일반 프로그래밍 에도 적용할 수 있습니다.

**단위 테스트 에서 모의 ​​객체는 복잡한 실제 객체의 동작을 시뮬레이션 할 수 있으므로 실제 객체가 비실용적이거나 단위 테스트에 통합할 수 없을 때 유용합니다.**

객체에 다음과 같은 특성이 있는 경우 그 자리에 모의 객체를 사용하는 것이 유용할 수 있습니다.

- 개체가 비결정적 결과(예: 현재 시간 또는 현재 온도)를 제공합니다.
- 생성하거나 재생산하기 어려운 상태(예: 네트워크 오류)가 있습니다.
- 속도가 느립니다.(예: 테스트 전에 초기화해야 하는 완전한 데이터베이스)
- 아직 존재하지 않거나 행동을 변경할 수 있습니다.
- 테스트 목적으로만 정보와 방법을 포함해야 합니다.(실제 작업이 아님)

### 나쁜 테스트 습관
* **통과할 테스트만 만드는 것**
	* 통과할 테스트를 만드는 것도 물론 중요하다. 그게 코드 refactor와 reorganize를 안전하게 만든다. 하지만 통과하지 못할 테스트도 만들어야 한다. 그래야 프로젝트가 진행되고 이슈 tracking이 가능해진다.
* **극단적 케이스에 대한 테스트를 고려하지 않는 것**
	* 프로젝트 일정 중간쯤에 성능평가 자동화 툴을 미리 만들어라. 그래야 더 심각해질 수 있는 문제를 방지할 수 있다.
* **빌드만 확인하고 동작 확인 안하기**
	* 빌드는 되지만 동작하지 않는 경우도 간혹 발생할 수 있다. 디버깅이 생각보다 골치아프고 오래 걸릴 수 있다. 빌드할 때마다 간단한 테스트를 하는 습관을 갖자.
* **큰 업데이트를 미루기**
	* 근자감에 취해 있다가 망하기 딱 좋은 케이스이다. 보통은 이걸로 여러 번 망해본 다음에야 정신을 차린다.
* **예전에 짠 코드를 더 이상 관리하지 않는 것**
	* 당신이 짠 코드를 당신보다 더 잘 아는 사람은 없다. 다른 사람이 당신 코드를 쓴다면 더 잘 이해할 수 있게 도와줘라. 가독성을 올릴 방법이 있다면 올려줘라.
* **기능 구현 이외의 사항을 무시하는 것**
	* 기능 구현에만 몰두하다 보면 성능, 보안 등의 문제를 소홀히 하기 쉽다. 이것들도 checklist에 적어두고 관리해야 한다. 이것들이 당신 작품의 가치를 떨어트릴지도 모를 일이다.

## 테스트 케이스와 그 한계
기획서에 기반하여 작성된 **테스트 케이스**(Test Case, TC)는 중요한 가이드 역할을 하지만, 모든 상황을 포괄하지 못할 가능성이 큽니다. **TC는 주로 Happy Path에 의존하기 때문에 외부 요인이나 예상치 못한 상황에 대해 취약할 수 있습니다.**

### Happy Path의 위험성

Happy Path Testing은 **모든 조건이 이상적으로 맞춰진 상태에서만 기능이 정상 동작하는지 확인하는 것**입니다. 하지만, 현실에서는 다양한 변수들이 영향을 미칩니다.

1. **다양한 디바이스 및 환경 문제**: 성능이 낮은 디바이스, 특정 OS 버전에서 발생하는 이슈 등은 Happy Path에서 제외될 수 있습니다.
2. **예상하지 못한 사용자 행동**: 유저들은 기획자나 개발자의 의도와 다르게 시스템을 사용하며, 이는 예상치 못한 오류로 이어질 수 있습니다.
3. **인적 실수**: 개발 과정에서 발생하는 실수나 버그는 테스트 케이스로는 발견하기 어려울 수 있습니다.

### 테스트 케이스 바깥의 세상

실제 발견되는 버그의 대부분은 TC 바깥에서 발생합니다. 이는 TC가 모든 비정상 상황을 다룰 수 없기 때문입니다. 그렇기 때문에 **테스트 케이스의 한계를 이해하고, 이를 넘어서려는 노력**이 필요합니다. 이때 **탐색적 테스팅**(Exploratory Testing)과 같은 비정형적인 테스트 방법이 중요해집니다.

## 탐색적 테스팅과 준비

탐색적 테스팅은 미리 정해진 절차 없이, **테스터의 경험과 직관을 바탕으로 다양한 비정상 상황을 탐구하는 방법**입니다. 이 방법은 발견하기 힘든 버그를 찾아내는 데 유용하지만, 목적 없이 실행하면 비효율적일 수 있습니다. 그래서 탐색적 테스팅을 잘 수행하려면 **명확한 목적**을 설정해야 합니다.

예를 들어:
- 특정 시스템 성능 문제를 중점적으로 파악하거나,
- 비정상적 입력을 통해 오류를 유도하는 식으로 테스트의 방향을 잡아야 합니다.

이 과정에서 비정상적 행동을 일부러 시도해 보는 것도 좋은 방법입니다. 예를 들어 **트롤링**(Trolling)과 같은 방식으로 게임의 정상 흐름을 방해하거나 의도와 반대되는 행동을 해보는 것입니다.

## 테스트 케이스와의 균형

그렇다고 해서 테스트 케이스의 중요성을 과소평가해서는 안 됩니다. **테스트 케이스는 프로젝트의 방향성을 잡아주는 나침반**과도 같습니다. 기획서에 기반한 테스트 케이스는 게임의 큰 틀에서 어떤 부분이 제대로 작동하는지 확인하는 중요한 역할을 합니다. **인수 테스트**(Acceptance Test)를 통해 제품이 고객의 요구사항을 충족하는지 검토하는 과정도 이와 유사합니다.

테스트 케이스는 새로운 팀원이 프로젝트에 빠르게 적응할 수 있도록 도와주고, **테스트 결과의 정량적 분석**을 가능하게 합니다. 즉, 테스트 케이스는 효율적인 품질 관리를 위해 반드시 필요하지만, **탐색적 테스팅과 같은 비정형적인 접근도 적절히 병행**해야 완성도 높은 결과를 얻을 수 있습니다.

### 테스트 케이스와 탐색적 테스팅

**테스트 케이스와 탐색적 테스팅은 상호 보완적**입니다. 둘 중 하나를 선택하는 것이 아니라, 두 가지 방식을 적절히 조화롭게 활용하여 버그를 더 많이 발견하고 소프트웨어의 품질을 높이는 것이 중요합니다. 특히 게임과 같은 복잡한 소프트웨어에서는 **Happy Path를 넘어선 테스트 전략**이 필요하며, 이를 통해 사용자에게 더욱 안전하고 신뢰할 수 있는 경험을 제공할 수 있을 것입니다.